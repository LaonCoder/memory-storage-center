깃(Git)과 깃허브(Github)의 기본 개념 및 명령어
===

![git_logo](/Additional_files/images/git_logo.png?raw=true)

---  

## < *Contents* >
- [1. 깃(Git)](#%EF%B8%8F-1-깃git)
- [2. 깃허브(Github)](#%EF%B8%8F-2-깃허브github)
- [3. 깃의 기본 용어 정리](#%EF%B8%8F-3-깃의-기본-용어-정리)
- [4. 깃의 기본 명령어 정리](#%EF%B8%8F-4-깃의-기본-명령어-정리)

---  

## ✔️ 1. 깃(Git)

- 깃은 **로컬**에서 관리되는 버전 관리 시스템(VCS: Version Control System)이다.  

    - 버전 관리 시스템(VCS)이란 파일의 변화를 시간에 따라 기록했다가, 나중에 특정 시점의 버전을 다시 불러올 수 있는 시스템이다.  

    - 깃은 분산 버전 관리 시스템(DVCS)에 해당한다.(중앙 서버(github)에 있는 코드를 개발자 각자의 로컬 컴퓨터에 복사한 후, 복사된 프로젝트를 가지고 작업하며 다시 서버에 업로드할 수 있다.)


- 깃을 사용하면 소스 코드 수정에 따른 버전 관리가 용이해지고, 여러 사람이 동시에 작업하는 병렬 개발이 가능해진다.  

## ✔️ 2. 깃허브(Github) 

- 깃허브는 분산형 버전 관리 시스템인 깃을 기반으로, 소스코드를 호스팅하고, 협업 지원 기능들을 지원하는 웹호스팅 서비스이다.  

    - **깃허브에서 제공해주는 클라우드 서버**를 통해 로컬에서 버전 관리한 소스코드를 업로드 하여 다른 사람들과 공유, 협업할 수 있다.

- 깃허브는 깃을 사용할 수 있는 리모트(원격) 공간/저장소를 제공해준다.  

## ✔️ 3. 깃의 기본 용어 정리

![git_Repo,workingDir,Stage](/Additional_files/images/git_presentation1.png?)

### **Repository(레포지토리)**  

- 프로젝트를 위한 파일들의 저장소를 의미하며, 히스토리, 태그, 소스 등을 Branch에 따라 버전별로 저장한다. 이러한 저장소는 크게 로컬 저장소와 원격(remote) 저장소로 나누어진다.  

### **Working Directory(작업 디렉토리)**  

- 사용자의 작업 공간으로, 로컬 저장소에 접근할 수 있으며 실제 파일을 수정하거나 생성하는 공간이다. 작업 트리(Work tree)라고도 한다.

    - 작업 디렉토리에서는 파일을 Tracked / Untracked 상태로 구분한다.  

    - 깃에서 작업 디렉토리에 있는 Untracked 상태의 파일을 Tracked 상태로 변경하는 것, 또는 작업 스테이지에 있는 파일을 스테이지(stage) 영역으로 복사하는 것을 등록이라고 한다.  

    ```bash
    $git add ~ # 등록 명령어
    ```  

### **Stage(스테이지)**   

- Working directory에서 등록된 tracked 상태의 파일들을 관리 및 임시로 저장하는 공간이다. 인덱스(Index)라고도 한다.

    - 스테이지 영역에서는 파일의 내용을 직접 가지고 있는 것이 아닌, 커밋하려는 파일의 추적 상태 정보들만 기록한다. (커밋을 빠르게 처리하기 위함.)  

    ```bash
    $git status | $git ls-files --stage  # 스테이지 확인 명령어
    ```  

### **Commit(커밋)**  

- 현재 변경된 작업 상태에 대한 점검(Stage에 등록)을 마친 뒤, 확정하여 저장소에 저장하는 작업을 의미한다. (히스토리의 한 지점)

    - 커밋을 하기 위해서는 반드시 Stage 영역으로 등록된 파일에 새로운 변경사항이 있어야 한다.  

    - 각 커밋에는 영문/숫자로 이루어진 40자리의 고유 이름이 붙는데, 저장소에선 이를 통해 각 커밋을 구분한다.

    - HEAD : 커밋을 가리키는 묵시적인 포인터로, 브랜치의 마지막 커밋의 작업 위치를 의미한다. 각각의 브랜치들은 각 브랜치에 대응되는 HEAD 포인터를 하나씩 가지며, 브랜치를 이동할 때 HEAD 포인터도 함께 이동한다.  

    - Snapshot 방식 : 변경된 파일의 전체를 저장하지 않고, 파일에서 변경된 부분만을 찾아 수정된 내용을 저장하는 방식이다. (부모 커밋을 기반으로 변화된 부분만을 이용하여 새로운 커밋 생성)  

### **Branch(브랜치)**  

- 분기점. 저장 공간 하나(main branch)에서 다른 가상의 저장공간을 만드는 것이다.  

    - 브랜치를 사용하면 프로젝트를 독립적으로 관리할 수 있다. (기존의 안정적인 코드와 개발 중인 작업을 구분하여 관리)  

    - 코드를 수정하고 커밋을 하면 "현재 사용중인" 브랜치(Current branch)의 제일 앞(Branch head)에 들어간다.  

    - 현재 내가 작업하는 워킹 트리(워킹 디렉토리)는 단 하나의 브랜치에 속해 있다.

    - 보통 브랜치를 생성하여 개발을 진행하고, 개발을 완료하면 main 브랜치에 병합하여 개발 완료된 소스코드를 합친다.  

## ✔️ 4. 깃의 기본 명령어 정리  

### **$ git init**
- "현재 디렉토리"를 기준으로 git 저장소가 생성된다.(초기화)
- git 저장소가 되었다는 증거는 디렉토리 내부에 .git 디렉토리가 생긴다는 것이다.  

### **$ git config**
- git 사용 환경 설정을 확인할 수 있다.  

### **$ git clone \<url>**
- 기존 소스 코드를 다운로드/복제한다.  

### **$ git status**
- 파일의 가능한 상태를 확인할 수 있다.
- 작업 디렉토리(Working directory)와 스테이징 영역(Staging area)의 상태를 확인하기 위해 사용한다.  

### **$ git log**
- 현재 위치한 브랜치 커밋 내용을 확인할 수 있고, 식별자가 부여된다.  

### **$ git remote add \<원격 저장소명> \<url(등록된 원격 서버 주소)>**
- <원격 저장소명>의 이름으로 원격 저장소를 등록(추가)한다.  

### **$ git remote remove <url(등록된 클라우드 주소)>**  
- 등록된 클라우드 주소를 삭제한다.  

### **$ git remote**
- 원격 저장소 목록을 확인한다.  

### **$ git branch**
- 브랜치 목록을 확인한다.

### **$ git branch <브랜치명>**
- (main 브랜치에서) <브랜치명> 브랜치를 생성한다.  

### **$ git branch -d <브랜치명>**
- <브랜치명> 브랜치를 제거한다.

### **$ git checkout (-b) <브랜치명>**
- 해당 브랜치로 이동한다.
- -b 옵션을 사용하면 브랜치 생성과 브랜치 이동을 동시에 할 수 있다.  

### **$ git merge \<다른 브랜치명>**
- 현재 브랜치에 다른 브랜치의 수정사항을 병합한다.
- 협업 과정에서 같은 이름의 파일 안에 수정한 부분이 겹칠 때 충돌이 발생할 수 있다.  

### **$ git add \<파일명>**
- 작업 디렉토리 상의 변경 내용을 스테이징 영역에 등록하기 위해 사용한다.   

### **$ git commit -m "커밋 메시지"**
- 파일 및 폴더의 추가/변경 사항을 (로컬)저장소에 저장한다.
- git commit 시 변경 내용이 head에 반영된다.  

### **$ git commit -m “커밋 메시지” --amend**
- 이전 커밋을 수정하고 커밋 메시지를 재사용한다.  

### **$ git reset HEAD \<파일명>**
- 스테이징 영역에 올려놓은 파일을 취소한다.
- 뒤에 파일명이 없으면 add한 파일 전체를 취소한다.  

### **$ git reset --soft/mixed/hard HEAD^(혹은 HEAD~{number})**
- 커밋을 취소할 수 있다. (HEAD 위치를 바꿔서 로컬 저장소의 상태를 커밋 이전 상태로 강제 변경한다.)  
    - --soft 옵션 : index, Working dir 보존
    - --mixed 옵션 : index 취소, Working dir 보존(default)
    - --hard 옵션 : index 취소, Working dir 삭제
- 해당 커밋 이후의 이력을 전부 삭제한다.  

- ※ reset 사용 시 주의할 점
    - hard 옵션으로 reset을 진행한 다음 push를 시도하면, 로컬 저장소의 커밋 히스토리가 원격 저장소의 커밋 히스토리보다 뒤에 있는데 push를 진행하려 한다는 오류가 발생한다. 이럴 때는 push에 -f 또는 --force 옵션을 주어 강제로 덮어쓴다.
    - reset은 혼자만 사용하는 브랜치이거나, 다른 사람들이 해당 브랜치를 받은 적이 없다고 확인된 경우에만 사용한다.

### **$ git revert**
- reset과 다르게 커밋을 삭제하는 것이 아닌 커밋을 추가한다.
- 이전 커밋과 정반대의 데이터를 추가하는 방식으로 코드를 되돌린다. (안전성↑)
- reset --soft, mixed와 같은 결과를 내지만, 이력은 Revert "..."이라는 커밋 메시지가 추가된다.

### **$ git push (-u) <저장소명> <브랜치명>**
- 로컬 저장소의 파일 변경 이력을 원격 저장소로 전송한다. (현재 프로젝트의 커밋된 내용(HEAD)을 원격 저장소로 내보낸다.)
- -u 옵션을 사용하면 앞으로 <브랜치명>이라는 현재 브랜치를 자동으로 <저장소명>이라는 원격저장소의 main 브랜치로 연결해 간단히 git push, git pull 만 입력하여 사용할 수 있게 된다.  

### **$ git pull <remote> <브랜치명>**
- 원격 저장소에서 변경된 내용을 가지고 온 후 현재 위치한 브랜치에 병합(merge)한다.
- pull = fetch + merge와 같은 의미이다.  

### **$ git fetch**
- 원격 저장소에서 변경된 내용(버전)을 가지고 온다. (병합X)
- 변경된 내역을 가지고 온 후 검토 후에 병합할 수 있어서 충돌을 방지할 수 있다.  






