4.Skip List
===
## < *Contents* >  
- [1. Skip List(스킵 리스트))](#%EF%B8%8F-1-skip-list스킵-리스트)

---  


## ✔️ 1. **Skip List(스킵 리스트)**
- 정렬된 연결 리스트에 이분검색 이론을 접합시킨 유사 연결 리스트이다.
- 모든 노드를 확인하면서 데이터를 탐색하는 것이 아니라, 몇몇 노드를 스킵하면서 탐색을 진행한다.  
    - 여러 계층(레벨)의 연결 리스트를 사용하여 구현한다.
    - 가장 높은 레벨부터 가장 낮은 레벨의 연결 리스트까지 순차적으로 탐색을 진행한다.
- 탐색/삽입/삭제 연산이 모두 평균적으로 <img src = "https://render.githubusercontent.com/render/math?math=O(log n)"> 정도 걸린다.  
- "Randomized Data Structure(랜덤화 자료구조)"이다.  
(입력되는 키 값과 상관없이, 난수에 의해 평균적인 성능이 달라진다.)  
</br>

### 1) **Perfect Skip List(완전 스킵 리스트)**
<p align="center"><img src="../Additional_files/images/skiplist1.png" width = 650></p>  

- i 레벨의 연결 리스트가 (i - 1) 레벨의 연결 리스트보다 1/2배 만큼 적은 수의 노드를 갖는다.  
(이때, i 레벨의 연속된 두 노드 사이에는 (i - 1) 레벨의 노드가 단 하나만 존재한다. - 규칙성)
- 탐색 연산은 <img src = "https://render.githubusercontent.com/render/math?math=O(log n)">으로 효율적이지만, 삽입/삭제 시 규칙성을 위해 Restructuring 을 거쳐야 하므로 비효율적이다.
- 스킵 리스트는 Randomization을 통해 어느정도 불균형을 주어 이러한 문제점을 보완한다.  
</br>

### 2) **Skip List(스킵 리스트)**
<p align="center"><img src="../Additional_files/images/skiplist2.png" width = 700></p>  

- 삽입되는 각각의 노드들은 <img src = "https://render.githubusercontent.com/render/math?math=\frac{1}{2}">의 확률로 상위 레벨을 가질 기회가 주어진다.  
    - 노드가 Level <img src = "https://render.githubusercontent.com/render/math?math=i"> 를 가질 확률은 <img src = "https://render.githubusercontent.com/render/math?math=\frac{1}{2}\cdot\frac{1}{2}\times\cdots\times\frac{1}{2} = (\frac{1}{2})^{i}"> 이다. (Level 0 에는 모든 노드가 포함된다.)  
    - 확률적으로 노드 레벨이 분포하게 된다.  
</br>

- 코드 구현
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    #include <limits.h>
    #include <math.h>

    #define MAX_LEVEL 3
    #define MIN_DATA INT_MIN


    typedef struct SkipNode SkipNode; 
    void ShowSkipList(SkipNode* pHeadNode);
    void SearchSkipList(SkipNode* pHeadNode, int data);
    void InsertSkipList(SkipNode** pHeadNode, int data);
    void DeleteSkipList(SkipNode** pHeadNode, int data);
    void FreeSkipList(SkipNode** pHeadNode);
    void FreeSkipNode(SkipNode* node);

    typedef struct SkipNode {
        int data;
        int level;
        struct SkipNode** forward;
    } SkipNode;
    ```
    ```c
    int main()
    {
        // Random 함수 시드 초기화
        srand(time(NULL));

        // 스킵 리스트 초기화 (헤더)
        SkipNode* SkipList = (SkipNode*)malloc(sizeof(SkipNode));
        SkipList->forward = (SkipNode**)malloc(sizeof(SkipNode*) * (MAX_LEVEL + 1));

        SkipList->level = MAX_LEVEL;
        SkipList->data = MIN_DATA;

        for (int i = 0; i <= SkipList->level; i++)
            SkipList->forward[i] = NULL;

        InsertSkipList(&SkipList, 2);
        InsertSkipList(&SkipList, 8);
        ShowSkipList(SkipList);

        InsertSkipList(&SkipList, 13);
        InsertSkipList(&SkipList, 21);
        ShowSkipList(SkipList);

        InsertSkipList(&SkipList, 11);
        InsertSkipList(&SkipList, 19);
        InsertSkipList(&SkipList, 10);
        ShowSkipList(SkipList);
        
        SearchSkipList(SkipList, 11);
        SearchSkipList(SkipList, 21);
        SearchSkipList(SkipList, 9);    // 스킵 리스트 범위 내에 포함되지만 존재하지 않는 경우
        SearchSkipList(SkipList, 0);  // 스킵 리스트 내 데이터의 최솟값보다 작은 경우
        SearchSkipList(SkipList, 100);  // 스킵 리스트 내 데이터의 최댓값보다 큰 경우

        DeleteSkipList(&SkipList, 11);
        DeleteSkipList(&SkipList, 12);  // 스킵 리스트 범위 내에 포함되지만 존재하지 않는 경우 
        DeleteSkipList(&SkipList, 1);   // 스킵 리스트 내 데이터의 최솟값보다 작은 경우
        DeleteSkipList(&SkipList, 30);  // 스킵 리스트 내 데이터의 최댓값보다 큰 경우

        ShowSkipList(SkipList);

        FreeSkipList(&SkipList);
    }
    ```
    ```c
    void ShowSkipList(SkipNode* pHeadNode)
    {
        SkipNode* pTmpNode = NULL;
        int i, j;

        // 레벨 별로 끝에 도달할 때까지 데이터 출력
        printf("-------------------------\n");
        for (i = MAX_LEVEL; i >= 0; i--)
        {
            pTmpNode = pHeadNode->forward[0];
            printf("Level %d:\t", i);
            while(pTmpNode != NULL)
            {
                if (pTmpNode->level >= i)
                    printf("%d-----", pTmpNode->data);
                else
                {
                    // data가 몇 자리인지에 따라 "-"의 출력 개수를 다르게 한다.
                    int tmp;
                    for (tmp = 0; pTmpNode->data / (int)pow(10, tmp + 1) != 0; tmp++);
                    tmp += 6;  // data가 한 자리 숫자일 때, 최소 길이 6 ("------")
                    for (; tmp > 0; tmp--)
                        printf("-");
                }

                pTmpNode = pTmpNode->forward[0];
            }
            printf("NULL\n");
        }
        printf("-------------------------\n");
    }
    ```
- 스킵 리스트 탐색 연산
    <p align="center"><img src="../Additional_files/images/skiplist3.png" width = 700></p>  

    ```c
    /* 스킵 리스트 안에서 해당 데이터를 탐색한다. */
    void SearchSkipList(SkipNode* pHeadNode, int data)
    {
        SkipNode* pTmpNode;

        // 찾고자 하는 데이터가 음수인 경우
        if (data < 0)
        {
            printf("Input data can't be negative.");
            return;
        }

        int pos = MAX_LEVEL;
        pTmpNode = pHeadNode->forward[pos];

        // (1) 현재 Level에 속한 노드가 없거나 data가 찾고자 하는 데이터보다 클 경우 Level을 감소시킨다.
        while (pTmpNode == NULL || pTmpNode->data > data)
        {
            pos--;

            if (pos < 0)  // 찾고자 하는 데이터가 스킵 리스트의 최솟값보다 작은 경우
            {
                printf("Search [%d] : ... there is no %d\n", data, data);
                return;
            }

            pTmpNode = pHeadNode->forward[pos];
        }
        
        printf("Search [%d] : ", data);

        // (2) 노드의 data가 찾고자 하는 데이터와 다를 경우
        while(pTmpNode->data != data)
        {
            // 현재 레벨에 속한 노드가 없거나 data가 찾고자 하는 데이터보다 클 경우 Level 감소시킨다.
            if (pTmpNode->forward[pos] == NULL || pTmpNode->forward[pos]->data > data)
            {
                pos -= 1;

                if (pos < 0)  // 찾고자 하는 데이터가 스킵 리스트 내부에 없는 경우
                {
                    printf("%d, ", pTmpNode->data);
                    printf("... there is no %d\n", data);
                    return;
                }
            }
            else
            {
                printf("%d, ", pTmpNode->data);
                pTmpNode = pTmpNode->forward[pos];
                // 노드의 data가 찾고자 하는 데이터와 같은 경우 
                if (pTmpNode->data == data)
                    break;
            }
        }
        printf("%d\n", pTmpNode->data);
    }
    ```
- 스킵 리스트 삽입 연산  
    <p align="center"><img src="../Additional_files/images/skiplist4.png" width = 700></p>  

    ```c
    /* 스킵 리스트에 해당 데이터를 삽입한다. */
    void InsertSkipList(SkipNode** pHeadNode, int data)
    {
        if (data < 0)
        {
            printf("Input data can't be negative.");
            return;
        }

        int level = 0, i, pos = MAX_LEVEL;
        // 새로운 데이터를 삽입할 위치에 오기까지 레벨별로 지나온 모든 노드들의 레퍼런스가 담긴 배열
        SkipNode* Update[MAX_LEVEL + 1];      
        SkipNode* pTmpNode = *pHeadNode;

        // Update 배열을 초기화한다. (모든 element가 head 노드를 가리킨다.)
        for(i = 0; i <= MAX_LEVEL; i++)
            Update[i] = *pHeadNode;

        // 레벨별로 지나온 노드들을 Update 배열에 저장한다.
        for (i = MAX_LEVEL; i >= 0; i--)
        {
            // 현재 레벨에서 추가될 노드의 직전 노드로 이동한다.
            while (pTmpNode->forward[i] != NULL)
            {
                if ((pTmpNode->forward[i])->data >= data)
                    break;
                pTmpNode = pTmpNode->forward[i];
            }
            Update[i] = pTmpNode;
        }

        // 이미 해당 데이터가 스킵 리스트 안에 존재하는 경우
        if (pTmpNode->forward[0] != NULL && pTmpNode->forward[0]->data == data)
        {
            printf("[%d] already exists in the list., data");
            return;
        }

        // 추가할 노드의 최대 레벨을 계산한다.(Coin Flipping)
        while (rand() % 2)
        {
            level++;
            if (level >= MAX_LEVEL)
                break;
        }
        
        // 추가할 노드에 메모리를 할당하고, 초기화한다.
        pTmpNode = (SkipNode*)malloc(sizeof(SkipNode));
        pTmpNode->forward = (SkipNode**)malloc(sizeof(SkipNode*) * (MAX_LEVEL + 1));
        pTmpNode->level = level;
        pTmpNode->data = data;
        for (i = 0; i <= MAX_LEVEL; i++)
            pTmpNode->forward[i] = NULL;

        // 추가할 노드의 level만큼 앞 뒤에 연결된 노드들을 연결한다.
        for (i = pTmpNode->level; i >= 0; i--)
        {
            pTmpNode->forward[i] = Update[i]->forward[i];
            Update[i]->forward[i] = pTmpNode;
        }
        printf("Insert [%d] with level [%d]\n", data, level);
    }
    ```
- 스킵 리스트 삭제 연산
    <p align="center"><img src="../Additional_files/images/skiplist5.png" width = 700></p>  

    ```c
    /* 스킵 리스트에 있는 해당 데이터를 삭제한다. */
    void DeleteSkipList(SkipNode** pHeadNode, int data)
    {
        // 삭제할 데이터가 음수인 경우
        if (data < 0)
        {
            printf("Input data can't be negative.");
            return;
        }

        int level = 0, i, pos = MAX_LEVEL;
        // 삭제할 노드의 위치에 오기까지 레벨별로 지나온 모든 노드들의 레퍼런스가 담긴 배열
        SkipNode* Update[MAX_LEVEL + 1];      
        SkipNode* pTmpNode = *pHeadNode;

        for(i = 0; i <= MAX_LEVEL; i++)
            Update[i] = *pHeadNode;

        for (i = MAX_LEVEL; i >= 0; i--)
        {
            while (pTmpNode->forward[i] != NULL)
            {
                if ((pTmpNode->forward[i])->data >= data)
                    break;
                pTmpNode = pTmpNode->forward[i];
            }
            Update[i] = pTmpNode;
        }
        // 삭제할 데이터를 갖는다고 예측되는 노드를 pCurNode에 저장한다.
        pTmpNode = pTmpNode->forward[0];

        // 삭제할 데이터가 스킵 리스트의 최대, 최소 범위를 벗어난 경우
        if (pTmpNode == NULL || (*pHeadNode)->forward[0]->data > data)
        {
            printf("[%d] does not exists in the list.\n", data);
            return;
        }
        // 예측된 노드가 삭제할 데이터를 갖고 있지 않은 경우
        else if (pTmpNode->data != data)
        {
            printf("[%d] does not exists in the list.\n", data);
            return;
        }

        // 삭제할 노드의 앞 뒤에 연결된 노드들을 연결한다.
        for (i = pTmpNode->level; i >= 0; i--)
            Update[i]->forward[i] = pTmpNode->forward[i];

        // 노드에 할당된 메모리를 해제한다.
        FreeSkipNode(pTmpNode);
        
        printf("Delete [%d] from the list.\n", data);
    }
    ```
    ```c
    /* 스킵 리스트에 할당된 모든 메모리를 해제한다. */
    void FreeSkipList(SkipNode** pHeadNode)
    {
        SkipNode *pCurNode = (*pHeadNode)->forward[0], *pNextNode;

        while (pNextNode != NULL)
        {
            pNextNode = pCurNode->forward[0];
            free(pCurNode->forward);
            free(pCurNode);
            pCurNode = pNextNode;
        }
        free((*pHeadNode)->forward);
        free(*pHeadNode);
    }


    /* 해당 노드에 할당된 모든 메모리를 해제한다. */
    void FreeSkipNode(SkipNode* node)
    {
        if (node)
        {
            free(node->forward);
            free(node);
        }
    }
    ```
    ```
    Insert [2] with level [1]
    Insert [8] with level [1]
    -------------------------
    Level 3:        ------------NULL
    Level 2:        ------------NULL
    Level 1:        2-----8-----NULL
    Level 0:        2-----8-----NULL
    -------------------------
    Insert [13] with level [1]
    Insert [21] with level [0]
    -------------------------
    Level 3:        --------------------------NULL
    Level 2:        --------------------------NULL
    Level 1:        2-----8-----13------------NULL
    Level 0:        2-----8-----13-----21-----NULL
    -------------------------
    Insert [11] with level [1]
    Insert [19] with level [0]
    Insert [10] with level [2]
    -------------------------
    Level 3:        -----------------------------------------------NULL
    Level 2:        ------------10---------------------------------NULL
    Level 1:        2-----8-----10-----11-----13-------------------NULL
    Level 0:        2-----8-----10-----11-----13-----19-----21-----NULL
    -------------------------
    Search [11] : 10, 11
    Search [21] : 10, 11, 13, 19, 21
    Search [9] : 2, 8, ... there is no 9
    Search [0] : ... there is no 0
    Search [100] : 10, 11, 13, 19, 21, ... there is no 100
    Delete [11] from the list.
    [12] does not exists in the list.
    [1] does not exists in the list.
    [30] does not exists in the list.
    -------------------------
    Level 3:        ----------------------------------------NULL
    Level 2:        ------------10--------------------------NULL
    Level 1:        2-----8-----10-----13-------------------NULL
    Level 0:        2-----8-----10-----13-----19-----21-----NULL
    -------------------------
    ```
- ※ 위와 같이 센티넬을 NULL이 아니라, 헤더 노드로 설정하여 스킵 리스트를 구현할 수도 있다.