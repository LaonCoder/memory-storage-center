1.Introduction
===

## ✔️ Recursive(재귀적) Algorithms
- **direct recursion** : call themselves
- **indirect recursion** : call other function that invoke the calling function again  

- 장점
    - 코드가 간결해진다.
    - 변수를 여러 개 만들 필요가 없다.  

- 단점
    - 반복문보다 큰 오버헤드(Overhead)를 갖는다.  
    (메모리 사용량이 더 많고, 수행 시간이 길어질 수 있다.)  
    - 함수 호출이 많아지면 StackOverFlow가 발생할 가능성이 있다.  

- (ex1) 반복문과 재귀호출을 이용한 이진 탐색(Binary Search)   

    - (1) 반복문
        ```c
        #include<stdio.h>
        // Macro를 사용하면 Type을 지정할 필요가 없다.
        #define COMPARE(x, y) (((x) > (y)) ? 1 : ((x) == (y)) ? 0 : -1)

        /* while문을 이용한 이진 탐색 알고리즘 */
        int binary_search(int list[], int search_num, int left, int right)
        {
            int middle;

            while (left <= right)
            {
                middle = (left + right) / 2;
                switch(COMPARE(list[middle], search_num))
                {
                    case 1: right = middle - 1; break;  // "Fall-through" 방지
                    case 0: return middle;
                    case -1: left = middle + 1;
                }
            }
            return -1;
        }


        void main()
        {
            int test_list[] = { 3, 5, 7, 10, 15, 17, 29, 35 };
            int len = sizeof(test_list) / sizeof(test_l[0]);
            int target1 = 3;
            int target2 = 35;
            int target3 = 40;
            int target4 = 6;

            printf("target1_loc : %d\n", binary_search(test_list, target1, 0, len - 1));
            printf("target2_loc : %d\n", binary_search(test_list, target2, 0, len - 1));
            printf("target3_loc : %d\n", binary_search(test_list, target3, 0, len - 1));
            printf("target4_loc : %d\n", binary_search(test_list, target4, 0, len - 1));
        }
        ```  

    - (2) 재귀호출
        ```c
        #include<stdio.h>
        #define COMPARE(x, y) (((x) > (y)) ? 1 : ((x) == (y)) ? 0 : -1)

        int binary_search(int list[], int search_num, int left, int right)
        {
            int middle;

            if (left <= right)  // 반복문이 필요가 없다.
            {
                middle = (left + right) / 2;
                switch(COMPARE(list[middle], search_num))
                {
                    case 1: 
                        return binary_search(list, search_num, left, middle - 1);
                    case 0: 
                        return middle;
                    case -1: 
                        return binary_search(list, search_num, middle + 1, right);
                }
            }
            return -1;
        }


        void main()
        {
            int test_list[] = { 3, 5, 7, 10, 15, 17, 29, 35 };
            int len = sizeof(test_list) / sizeof(test_l[0]);
            int target1 = 3;
            int target2 = 35;
            int target3 = 40;
            int target4 = 6;

            printf("target1_loc : %d\n", binary_search(test_list, target1, 0, len - 1));
            printf("target2_loc : %d\n", binary_search(test_list, target2, 0, len - 1));
            printf("target3_loc : %d\n", binary_search(test_list, target3, 0, len - 1));
            printf("target4_loc : %d\n", binary_search(test_list, target4, 0, len - 1));
        }
        ```  
    
- (ex2) 재귀 호출을 이용한 Permutation  

    - 코드 구현 )
        ```c
        #include <stdio.h>
        // 두 변수 안의 데이터를 서로 바꾼다.
        #define SWAP(x, y) temp = *x; \
                        *x = *y; \
                        *y = temp;

        /* 리스트 안의 element들로 만든 permutation을 구한다. */
        void permutation(char *list, int i, int n)
        {
            int j, temp;

            if (i == n)                     // 마지막 자리까지 간 경우 출력한다. (ex) abcd
            {
                for (j = 0; j <= n; j++)
                    printf("%c", list[j]);  
                printf("\n");
            }
            else                            
            {
                for (j = i; j <= n; j++)
                {
                    SWAP(&list[i], &list[j]);   // 두 element를 swap한다.
                    permutation(list, i+1, n);  // list의 일부에 대해 Recursion
                    SWAP(&list[i], &list[j]);   // swap한 element들을 되돌려 놓는다.
                }
            }
        }


        void main()
        {
            char test_list[] = { 'a', 'b', 'c', 'd' };
            int len = sizeof(test_list) / sizeof(test_list[0]);

            permutation(test_list, 0, len - 1);
        }
        ```  

    - 참고 이미지 )
        ![permutation](/Additional_files/images/permutation1.png?raw=true)